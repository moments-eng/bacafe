/* tslint:disable */
/* eslint-disable */
/**
 * Backend API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddArticleToOnboardingDto
 */
export interface AddArticleToOnboardingDto {
    /**
     * Article ID to add
     * @type {string}
     * @memberof AddArticleToOnboardingDto
     */
    'articleId': string;
    /**
     * Position in the onboarding flow
     * @type {number}
     * @memberof AddArticleToOnboardingDto
     */
    'position': number;
}
/**
 * 
 * @export
 * @interface ArticleDto
 */
export interface ArticleDto {
    /**
     * Article ID
     * @type {string}
     * @memberof ArticleDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ArticleDto
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ArticleDto
     */
    'subtitle': string;
    /**
     * 
     * @type {string}
     * @memberof ArticleDto
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof ArticleDto
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ArticleDto
     */
    'source': string;
    /**
     * 
     * @type {string}
     * @memberof ArticleDto
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof ArticleDto
     */
    'description'?: string;
    /**
     * 
     * @type {ArticleImageDto}
     * @memberof ArticleDto
     */
    'image'?: ArticleImageDto;
    /**
     * 
     * @type {Array<string>}
     * @memberof ArticleDto
     */
    'categories': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ArticleDto
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ArticleDto
     */
    'externalId': string;
    /**
     * 
     * @type {object}
     * @memberof ArticleDto
     */
    'enrichment'?: object;
    /**
     * 
     * @type {string}
     * @memberof ArticleDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ArticleDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface ArticleFilterDto
 */
export interface ArticleFilterDto {
    /**
     * 
     * @type {string}
     * @memberof ArticleFilterDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ArticleFilterDto
     */
    'subtitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof ArticleFilterDto
     */
    'source'?: string;
    /**
     * 
     * @type {string}
     * @memberof ArticleFilterDto
     */
    'author'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ArticleFilterDto
     */
    'categories'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ArticleFilterDto
     */
    'publishedAtFrom'?: string;
    /**
     * 
     * @type {string}
     * @memberof ArticleFilterDto
     */
    'publishedAtTo'?: string;
}
/**
 * 
 * @export
 * @interface ArticleImageDto
 */
export interface ArticleImageDto {
    /**
     * 
     * @type {string}
     * @memberof ArticleImageDto
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ArticleImageDto
     */
    'credit'?: string;
}
/**
 * 
 * @export
 * @interface ArticlePositionDto
 */
export interface ArticlePositionDto {
    /**
     * Article ID
     * @type {string}
     * @memberof ArticlePositionDto
     */
    'articleId': string;
    /**
     * Position in the onboarding flow
     * @type {number}
     * @memberof ArticlePositionDto
     */
    'position': number;
}
/**
 * 
 * @export
 * @interface ArticleSortDto
 */
export interface ArticleSortDto {
    /**
     * 
     * @type {string}
     * @memberof ArticleSortDto
     */
    'title'?: ArticleSortDtoTitleEnum;
    /**
     * 
     * @type {string}
     * @memberof ArticleSortDto
     */
    'publishedAt'?: ArticleSortDtoPublishedAtEnum;
    /**
     * 
     * @type {string}
     * @memberof ArticleSortDto
     */
    'createdAt'?: ArticleSortDtoCreatedAtEnum;
}

export const ArticleSortDtoTitleEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type ArticleSortDtoTitleEnum = typeof ArticleSortDtoTitleEnum[keyof typeof ArticleSortDtoTitleEnum];
export const ArticleSortDtoPublishedAtEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type ArticleSortDtoPublishedAtEnum = typeof ArticleSortDtoPublishedAtEnum[keyof typeof ArticleSortDtoPublishedAtEnum];
export const ArticleSortDtoCreatedAtEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type ArticleSortDtoCreatedAtEnum = typeof ArticleSortDtoCreatedAtEnum[keyof typeof ArticleSortDtoCreatedAtEnum];

/**
 * 
 * @export
 * @interface ArticleStatsDto
 */
export interface ArticleStatsDto {
    /**
     * Total number of articles
     * @type {number}
     * @memberof ArticleStatsDto
     */
    'totalArticles': number;
    /**
     * Count of articles per provider/source
     * @type {object}
     * @memberof ArticleStatsDto
     */
    'articlesPerProvider': object;
    /**
     * List of distinct providers/sources
     * @type {Array<string>}
     * @memberof ArticleStatsDto
     */
    'providers': Array<string>;
    /**
     * Number of scraped articles
     * @type {number}
     * @memberof ArticleStatsDto
     */
    'scrapedCount': number;
    /**
     * Number of enriched articles
     * @type {number}
     * @memberof ArticleStatsDto
     */
    'enrichedCount': number;
}
/**
 * 
 * @export
 * @interface CreateArticleDto
 */
export interface CreateArticleDto {
    /**
     * The URL of the article to scrape
     * @type {string}
     * @memberof CreateArticleDto
     */
    'url': string;
    /**
     * The source/provider of the article
     * @type {string}
     * @memberof CreateArticleDto
     */
    'source': string;
    /**
     * Optional external ID for the article
     * @type {string}
     * @memberof CreateArticleDto
     */
    'externalId'?: string;
    /**
     * Whether to force rescraping if the article already exists
     * @type {boolean}
     * @memberof CreateArticleDto
     */
    'forceScrape'?: boolean;
    /**
     * Article title
     * @type {string}
     * @memberof CreateArticleDto
     */
    'title'?: string;
    /**
     * Article subtitle
     * @type {string}
     * @memberof CreateArticleDto
     */
    'subtitle'?: string;
    /**
     * Article content
     * @type {string}
     * @memberof CreateArticleDto
     */
    'content'?: string;
    /**
     * Article author
     * @type {string}
     * @memberof CreateArticleDto
     */
    'author'?: string;
    /**
     * Article description
     * @type {string}
     * @memberof CreateArticleDto
     */
    'description'?: string;
    /**
     * Publication date
     * @type {string}
     * @memberof CreateArticleDto
     */
    'publishedAt'?: string;
    /**
     * Article image
     * @type {CreateArticleImageDto}
     * @memberof CreateArticleDto
     */
    'image'?: CreateArticleImageDto;
    /**
     * Article categories
     * @type {Array<string>}
     * @memberof CreateArticleDto
     */
    'categories'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateArticleImageDto
 */
export interface CreateArticleImageDto {
    /**
     * URL of the article image
     * @type {string}
     * @memberof CreateArticleImageDto
     */
    'url': string;
    /**
     * Image credit/attribution
     * @type {string}
     * @memberof CreateArticleImageDto
     */
    'credit'?: string;
}
/**
 * 
 * @export
 * @interface CreateFeedDto
 */
export interface CreateFeedDto {
    /**
     * The news provider name (e.g., ynet, mako)
     * @type {string}
     * @memberof CreateFeedDto
     */
    'provider': string;
    /**
     * The RSS feed URL
     * @type {string}
     * @memberof CreateFeedDto
     */
    'url': string;
    /**
     * Categories for the feed content
     * @type {Array<string>}
     * @memberof CreateFeedDto
     */
    'categories': Array<string>;
}
/**
 * 
 * @export
 * @interface CreateOnboardingDto
 */
export interface CreateOnboardingDto {
    /**
     * Articles with their positions in the onboarding flow
     * @type {Array<OnboardingArticleDto>}
     * @memberof CreateOnboardingDto
     */
    'articles': Array<OnboardingArticleDto>;
}
/**
 * 
 * @export
 * @interface DigestContentDto
 */
export interface DigestContentDto {
    /**
     * A collection of sections in the news digest
     * @type {Array<SectionDto>}
     * @memberof DigestContentDto
     */
    'sections': Array<SectionDto>;
    /**
     * A short Hebrew teaser for the entire digest
     * @type {string}
     * @memberof DigestContentDto
     */
    'teaser': string;
    /**
     * A string representing the current date (e.g., 2025-01-31)
     * @type {string}
     * @memberof DigestContentDto
     */
    'date': string;
    /**
     * Approximate total read time for the entire digest in minutes
     * @type {number}
     * @memberof DigestContentDto
     */
    'readTime': number;
}
/**
 * 
 * @export
 * @interface FeedDto
 */
export interface FeedDto {
    /**
     * Feed ID
     * @type {string}
     * @memberof FeedDto
     */
    'id': string;
    /**
     * The name of the feed
     * @type {string}
     * @memberof FeedDto
     */
    'name': string;
    /**
     * The RSS feed URL
     * @type {string}
     * @memberof FeedDto
     */
    'url': string;
    /**
     * The news provider name
     * @type {string}
     * @memberof FeedDto
     */
    'provider': string;
    /**
     * The feed language
     * @type {string}
     * @memberof FeedDto
     */
    'language': string;
    /**
     * Whether the feed is active
     * @type {boolean}
     * @memberof FeedDto
     */
    'isActive': boolean;
    /**
     * Feed categories
     * @type {Array<string>}
     * @memberof FeedDto
     */
    'categories': Array<string>;
    /**
     * Feed description
     * @type {string}
     * @memberof FeedDto
     */
    'description'?: string;
    /**
     * Scraping interval in minutes
     * @type {number}
     * @memberof FeedDto
     */
    'scrapingInterval': number;
    /**
     * Last scraping timestamp
     * @type {string}
     * @memberof FeedDto
     */
    'lastScrapedAt': string;
}
/**
 * 
 * @export
 * @interface OnboardingArticleDto
 */
export interface OnboardingArticleDto {
    /**
     * Article ID
     * @type {string}
     * @memberof OnboardingArticleDto
     */
    'articleId': string;
    /**
     * Position in onboarding flow
     * @type {number}
     * @memberof OnboardingArticleDto
     */
    'position': number;
}
/**
 * 
 * @export
 * @interface OnboardingArticlePositionDto
 */
export interface OnboardingArticlePositionDto {
    /**
     * The article in the onboarding flow
     * @type {ArticleDto}
     * @memberof OnboardingArticlePositionDto
     */
    'article': ArticleDto;
    /**
     * Position of the article in the onboarding flow
     * @type {number}
     * @memberof OnboardingArticlePositionDto
     */
    'position': number;
}
/**
 * 
 * @export
 * @interface OnboardingDto
 */
export interface OnboardingDto {
    /**
     * Onboarding ID
     * @type {string}
     * @memberof OnboardingDto
     */
    'id': string;
    /**
     * Articles with their positions in the onboarding flow
     * @type {Array<OnboardingArticlePositionDto>}
     * @memberof OnboardingDto
     */
    'articles': Array<OnboardingArticlePositionDto>;
    /**
     * Created at timestamp
     * @type {string}
     * @memberof OnboardingDto
     */
    'createdAt': string;
    /**
     * Updated at timestamp
     * @type {string}
     * @memberof OnboardingDto
     */
    'updatedAt': string;
    /**
     * Whether this is the production version
     * @type {boolean}
     * @memberof OnboardingDto
     */
    'isProduction': boolean;
}
/**
 * 
 * @export
 * @interface PaginatedArticlesDto
 */
export interface PaginatedArticlesDto {
    /**
     * 
     * @type {Array<ArticleDto>}
     * @memberof PaginatedArticlesDto
     */
    'items': Array<ArticleDto>;
    /**
     * 
     * @type {number}
     * @memberof PaginatedArticlesDto
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedArticlesDto
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedArticlesDto
     */
    'totalPages': number;
    /**
     * 
     * @type {boolean}
     * @memberof PaginatedArticlesDto
     */
    'hasNextPage': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PaginatedArticlesDto
     */
    'hasPreviousPage': boolean;
}
/**
 * 
 * @export
 * @interface PaginatedOnboardingDto
 */
export interface PaginatedOnboardingDto {
    /**
     * 
     * @type {Array<OnboardingDto>}
     * @memberof PaginatedOnboardingDto
     */
    'items': Array<OnboardingDto>;
    /**
     * Total number of items
     * @type {number}
     * @memberof PaginatedOnboardingDto
     */
    'total': number;
    /**
     * Current page number
     * @type {number}
     * @memberof PaginatedOnboardingDto
     */
    'page': number;
    /**
     * Total number of pages
     * @type {number}
     * @memberof PaginatedOnboardingDto
     */
    'totalPages': number;
    /**
     * Whether there is a next page
     * @type {boolean}
     * @memberof PaginatedOnboardingDto
     */
    'hasNextPage': boolean;
    /**
     * Whether there is a previous page
     * @type {boolean}
     * @memberof PaginatedOnboardingDto
     */
    'hasPreviousPage': boolean;
}
/**
 * 
 * @export
 * @interface QueryArticlesDto
 */
export interface QueryArticlesDto {
    /**
     * 
     * @type {ArticleFilterDto}
     * @memberof QueryArticlesDto
     */
    'filter'?: ArticleFilterDto;
    /**
     * 
     * @type {ArticleSortDto}
     * @memberof QueryArticlesDto
     */
    'sort'?: ArticleSortDto;
    /**
     * 
     * @type {number}
     * @memberof QueryArticlesDto
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryArticlesDto
     */
    'limit'?: number;
}
/**
 * 
 * @export
 * @interface SectionDto
 */
export interface SectionDto {
    /**
     * The category or tag for the section
     * @type {string}
     * @memberof SectionDto
     */
    'category': string;
    /**
     * A catchy Hebrew title for the section
     * @type {string}
     * @memberof SectionDto
     */
    'title': string;
    /**
     * A short Hebrew teaser summarizing the section
     * @type {string}
     * @memberof SectionDto
     */
    'teaser': string;
    /**
     * 1–3 Hebrew bullet points highlighting key info
     * @type {Array<string>}
     * @memberof SectionDto
     */
    'highlights': Array<string>;
    /**
     * 1–3 short Hebrew paragraphs summarizing the section\'s articles
     * @type {Array<string>}
     * @memberof SectionDto
     */
    'body': Array<string>;
    /**
     * A list of URLs for the included articles
     * @type {Array<string>}
     * @memberof SectionDto
     */
    'articleLinks': Array<string>;
    /**
     * Link to an image relevant to the section
     * @type {string}
     * @memberof SectionDto
     */
    'imageUrl': string;
    /**
     * Approximate read time in minutes
     * @type {number}
     * @memberof SectionDto
     */
    'readTime'?: number;
    /**
     * Mood indicator for the section
     * @type {string}
     * @memberof SectionDto
     */
    'mood'?: SectionDtoMoodEnum;
}

export const SectionDtoMoodEnum = {
    Positive: 'positive',
    Negative: 'negative',
    Neutral: 'neutral'
} as const;

export type SectionDtoMoodEnum = typeof SectionDtoMoodEnum[keyof typeof SectionDtoMoodEnum];

/**
 * 
 * @export
 * @interface UpdateArticleDto
 */
export interface UpdateArticleDto {
    /**
     * Article title
     * @type {string}
     * @memberof UpdateArticleDto
     */
    'title'?: string;
    /**
     * Article subtitle
     * @type {string}
     * @memberof UpdateArticleDto
     */
    'subtitle'?: string;
    /**
     * Article description
     * @type {string}
     * @memberof UpdateArticleDto
     */
    'description'?: string;
    /**
     * Article author
     * @type {string}
     * @memberof UpdateArticleDto
     */
    'author'?: string;
    /**
     * Article image information
     * @type {UpdateArticleImageDto}
     * @memberof UpdateArticleDto
     */
    'image'?: UpdateArticleImageDto;
    /**
     * Article categories
     * @type {Array<string>}
     * @memberof UpdateArticleDto
     */
    'categories'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateArticleDto
     */
    'content'?: string;
    /**
     * Article enrichment data
     * @type {object}
     * @memberof UpdateArticleDto
     */
    'enrichment'?: object;
}
/**
 * 
 * @export
 * @interface UpdateArticleImageDto
 */
export interface UpdateArticleImageDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateArticleImageDto
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateArticleImageDto
     */
    'credit'?: string;
}
/**
 * 
 * @export
 * @interface UpdateArticlePositionsDto
 */
export interface UpdateArticlePositionsDto {
    /**
     * List of article positions to update
     * @type {Array<ArticlePositionDto>}
     * @memberof UpdateArticlePositionsDto
     */
    'positions': Array<ArticlePositionDto>;
}
/**
 * 
 * @export
 * @interface UpdateFeedDto
 */
export interface UpdateFeedDto {
    /**
     * Whether the feed is active
     * @type {boolean}
     * @memberof UpdateFeedDto
     */
    'isActive'?: boolean;
    /**
     * Scraping interval in minutes
     * @type {number}
     * @memberof UpdateFeedDto
     */
    'scrapingInterval'?: number;
    /**
     * Feed name
     * @type {string}
     * @memberof UpdateFeedDto
     */
    'name'?: string;
    /**
     * Feed categories
     * @type {Array<string>}
     * @memberof UpdateFeedDto
     */
    'categories'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateFeedStatusDto
 */
export interface UpdateFeedStatusDto {
    /**
     * Whether the feed is active
     * @type {boolean}
     * @memberof UpdateFeedStatusDto
     */
    'isActive': boolean;
    /**
     * Scraping interval in minutes (-1 for inactive)
     * @type {number}
     * @memberof UpdateFeedStatusDto
     */
    'scrapingInterval'?: number;
}
/**
 * 
 * @export
 * @interface UpdateScrapingResultDto
 */
export interface UpdateScrapingResultDto {
    /**
     * The scraped title of the article
     * @type {string}
     * @memberof UpdateScrapingResultDto
     */
    'title'?: string;
    /**
     * The scraped subtitle/description of the article
     * @type {string}
     * @memberof UpdateScrapingResultDto
     */
    'subtitle'?: string;
    /**
     * Article description
     * @type {string}
     * @memberof UpdateScrapingResultDto
     */
    'description'?: string;
    /**
     * The author of the article
     * @type {string}
     * @memberof UpdateScrapingResultDto
     */
    'author'?: string;
    /**
     * The scraped image information
     * @type {CreateArticleImageDto}
     * @memberof UpdateScrapingResultDto
     */
    'image'?: CreateArticleImageDto;
    /**
     * Article categories
     * @type {Array<string>}
     * @memberof UpdateScrapingResultDto
     */
    'categories'?: Array<string>;
    /**
     * The scraped content of the article
     * @type {string}
     * @memberof UpdateScrapingResultDto
     */
    'content': string;
    /**
     * The publication date of the article
     * @type {string}
     * @memberof UpdateScrapingResultDto
     */
    'publishedAt': string;
    /**
     * The scraping status of the article
     * @type {string}
     * @memberof UpdateScrapingResultDto
     */
    'scrapingStatus': UpdateScrapingResultDtoScrapingStatusEnum;
    /**
     * Error message if scraping failed
     * @type {string}
     * @memberof UpdateScrapingResultDto
     */
    'scrapingError'?: string;
}

export const UpdateScrapingResultDtoScrapingStatusEnum = {
    Pending: 'PENDING',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Failed: 'FAILED'
} as const;

export type UpdateScrapingResultDtoScrapingStatusEnum = typeof UpdateScrapingResultDtoScrapingStatusEnum[keyof typeof UpdateScrapingResultDtoScrapingStatusEnum];

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * User ID
     * @type {object}
     * @memberof User
     */
    '_id': object;
}

/**
 * AppApi - axios parameter creator
 * @export
 */
export const AppApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppApi - functional programming interface
 * @export
 */
export const AppApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppApi.healthCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AppApi - factory interface
 * @export
 */
export const AppApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppApiFp(configuration)
    return {
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.healthCheck(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AppApi - object-oriented interface
 * @export
 * @class AppApi
 * @extends {BaseAPI}
 */
export class AppApi extends BaseAPI {
    /**
     * 
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppApi
     */
    public healthCheck(options?: RawAxiosRequestConfig) {
        return AppApiFp(this.configuration).healthCheck(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ArticlesApi - axios parameter creator
 * @export
 */
export const ArticlesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new article and queues it for scraping. If the article exists and forceScrape is true, it will be re-scraped.
         * @summary Create a new article
         * @param {CreateArticleDto} createArticleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArticle: async (createArticleDto: CreateArticleDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createArticleDto' is not null or undefined
            assertParamExists('createArticle', 'createArticleDto', createArticleDto)
            const localVarPath = `/articles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createArticleDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes an article by its ID
         * @summary Delete article
         * @param {string} id Article ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArticle: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteArticle', 'id', id)
            const localVarPath = `/articles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns aggregated statistics about articles
         * @summary Get article statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticleStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/articles/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns articles sorted by creation date (newest first)
         * @summary List articles with pagination
         * @param {number} [page] Page number (1-based)
         * @param {number} [limit] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArticles: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/articles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns filtered and sorted articles with pagination
         * @summary Query articles with filters and sorting
         * @param {QueryArticlesDto} queryArticlesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryArticles: async (queryArticlesDto: QueryArticlesDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queryArticlesDto' is not null or undefined
            assertParamExists('queryArticles', 'queryArticlesDto', queryArticlesDto)
            const localVarPath = `/articles/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryArticlesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates article metadata and enrichment data
         * @summary Update article metadata
         * @param {string} id Article ID
         * @param {UpdateArticleDto} updateArticleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArticle: async (id: string, updateArticleDto: UpdateArticleDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateArticle', 'id', id)
            // verify required parameter 'updateArticleDto' is not null or undefined
            assertParamExists('updateArticle', 'updateArticleDto', updateArticleDto)
            const localVarPath = `/articles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateArticleDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an article with the results from scraping, including content and status
         * @summary Update article with scraping results
         * @param {string} id Article ID
         * @param {UpdateScrapingResultDto} updateScrapingResultDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScrapingResult: async (id: string, updateScrapingResultDto: UpdateScrapingResultDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateScrapingResult', 'id', id)
            // verify required parameter 'updateScrapingResultDto' is not null or undefined
            assertParamExists('updateScrapingResult', 'updateScrapingResultDto', updateScrapingResultDto)
            const localVarPath = `/articles/{id}/scraping-result`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateScrapingResultDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArticlesApi - functional programming interface
 * @export
 */
export const ArticlesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArticlesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new article and queues it for scraping. If the article exists and forceScrape is true, it will be re-scraped.
         * @summary Create a new article
         * @param {CreateArticleDto} createArticleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createArticle(createArticleDto: CreateArticleDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArticleDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createArticle(createArticleDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArticlesApi.createArticle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently deletes an article by its ID
         * @summary Delete article
         * @param {string} id Article ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteArticle(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteArticle(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArticlesApi.deleteArticle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns aggregated statistics about articles
         * @summary Get article statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArticleStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArticleStatsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArticleStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArticlesApi.getArticleStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns articles sorted by creation date (newest first)
         * @summary List articles with pagination
         * @param {number} [page] Page number (1-based)
         * @param {number} [limit] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listArticles(page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedArticlesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listArticles(page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArticlesApi.listArticles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns filtered and sorted articles with pagination
         * @summary Query articles with filters and sorting
         * @param {QueryArticlesDto} queryArticlesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryArticles(queryArticlesDto: QueryArticlesDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedArticlesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryArticles(queryArticlesDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArticlesApi.queryArticles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates article metadata and enrichment data
         * @summary Update article metadata
         * @param {string} id Article ID
         * @param {UpdateArticleDto} updateArticleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArticle(id: string, updateArticleDto: UpdateArticleDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArticleDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateArticle(id, updateArticleDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArticlesApi.updateArticle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an article with the results from scraping, including content and status
         * @summary Update article with scraping results
         * @param {string} id Article ID
         * @param {UpdateScrapingResultDto} updateScrapingResultDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateScrapingResult(id: string, updateScrapingResultDto: UpdateScrapingResultDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArticleDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScrapingResult(id, updateScrapingResultDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArticlesApi.updateScrapingResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ArticlesApi - factory interface
 * @export
 */
export const ArticlesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArticlesApiFp(configuration)
    return {
        /**
         * Creates a new article and queues it for scraping. If the article exists and forceScrape is true, it will be re-scraped.
         * @summary Create a new article
         * @param {CreateArticleDto} createArticleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArticle(createArticleDto: CreateArticleDto, options?: RawAxiosRequestConfig): AxiosPromise<ArticleDto> {
            return localVarFp.createArticle(createArticleDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes an article by its ID
         * @summary Delete article
         * @param {string} id Article ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArticle(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteArticle(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns aggregated statistics about articles
         * @summary Get article statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticleStats(options?: RawAxiosRequestConfig): AxiosPromise<ArticleStatsDto> {
            return localVarFp.getArticleStats(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns articles sorted by creation date (newest first)
         * @summary List articles with pagination
         * @param {number} [page] Page number (1-based)
         * @param {number} [limit] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArticles(page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedArticlesDto> {
            return localVarFp.listArticles(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns filtered and sorted articles with pagination
         * @summary Query articles with filters and sorting
         * @param {QueryArticlesDto} queryArticlesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryArticles(queryArticlesDto: QueryArticlesDto, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedArticlesDto> {
            return localVarFp.queryArticles(queryArticlesDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates article metadata and enrichment data
         * @summary Update article metadata
         * @param {string} id Article ID
         * @param {UpdateArticleDto} updateArticleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArticle(id: string, updateArticleDto: UpdateArticleDto, options?: RawAxiosRequestConfig): AxiosPromise<ArticleDto> {
            return localVarFp.updateArticle(id, updateArticleDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an article with the results from scraping, including content and status
         * @summary Update article with scraping results
         * @param {string} id Article ID
         * @param {UpdateScrapingResultDto} updateScrapingResultDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScrapingResult(id: string, updateScrapingResultDto: UpdateScrapingResultDto, options?: RawAxiosRequestConfig): AxiosPromise<ArticleDto> {
            return localVarFp.updateScrapingResult(id, updateScrapingResultDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArticlesApi - object-oriented interface
 * @export
 * @class ArticlesApi
 * @extends {BaseAPI}
 */
export class ArticlesApi extends BaseAPI {
    /**
     * Creates a new article and queues it for scraping. If the article exists and forceScrape is true, it will be re-scraped.
     * @summary Create a new article
     * @param {CreateArticleDto} createArticleDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public createArticle(createArticleDto: CreateArticleDto, options?: RawAxiosRequestConfig) {
        return ArticlesApiFp(this.configuration).createArticle(createArticleDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes an article by its ID
     * @summary Delete article
     * @param {string} id Article ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public deleteArticle(id: string, options?: RawAxiosRequestConfig) {
        return ArticlesApiFp(this.configuration).deleteArticle(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns aggregated statistics about articles
     * @summary Get article statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public getArticleStats(options?: RawAxiosRequestConfig) {
        return ArticlesApiFp(this.configuration).getArticleStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns articles sorted by creation date (newest first)
     * @summary List articles with pagination
     * @param {number} [page] Page number (1-based)
     * @param {number} [limit] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public listArticles(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return ArticlesApiFp(this.configuration).listArticles(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns filtered and sorted articles with pagination
     * @summary Query articles with filters and sorting
     * @param {QueryArticlesDto} queryArticlesDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public queryArticles(queryArticlesDto: QueryArticlesDto, options?: RawAxiosRequestConfig) {
        return ArticlesApiFp(this.configuration).queryArticles(queryArticlesDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates article metadata and enrichment data
     * @summary Update article metadata
     * @param {string} id Article ID
     * @param {UpdateArticleDto} updateArticleDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public updateArticle(id: string, updateArticleDto: UpdateArticleDto, options?: RawAxiosRequestConfig) {
        return ArticlesApiFp(this.configuration).updateArticle(id, updateArticleDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an article with the results from scraping, including content and status
     * @summary Update article with scraping results
     * @param {string} id Article ID
     * @param {UpdateScrapingResultDto} updateScrapingResultDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public updateScrapingResult(id: string, updateScrapingResultDto: UpdateScrapingResultDto, options?: RawAxiosRequestConfig) {
        return ArticlesApiFp(this.configuration).updateScrapingResult(id, updateScrapingResultDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DailyDigestApi - axios parameter creator
 * @export
 */
export const DailyDigestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Admin-only endpoint to manually trigger daily digest delivery for testing purposes
         * @summary Deliver latest daily digest for a user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliverDailyDigest: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deliverDailyDigest', 'userId', userId)
            const localVarPath = `/daily-digest/deliver/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the most recent daily digest for the specified user from today
         * @summary Get latest daily digest for a user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestDailyDigest: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getLatestDailyDigest', 'userId', userId)
            const localVarPath = `/daily-digest/{userId}/latest`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Admin-only endpoint to manually trigger daily digest generation for testing purposes
         * @summary Trigger daily digest generation for a user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerDailyDigest: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('triggerDailyDigest', 'userId', userId)
            const localVarPath = `/daily-digest/trigger/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DailyDigestApi - functional programming interface
 * @export
 */
export const DailyDigestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DailyDigestApiAxiosParamCreator(configuration)
    return {
        /**
         * Admin-only endpoint to manually trigger daily digest delivery for testing purposes
         * @summary Deliver latest daily digest for a user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deliverDailyDigest(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deliverDailyDigest(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DailyDigestApi.deliverDailyDigest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the most recent daily digest for the specified user from today
         * @summary Get latest daily digest for a user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestDailyDigest(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DigestContentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestDailyDigest(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DailyDigestApi.getLatestDailyDigest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Admin-only endpoint to manually trigger daily digest generation for testing purposes
         * @summary Trigger daily digest generation for a user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerDailyDigest(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerDailyDigest(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DailyDigestApi.triggerDailyDigest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DailyDigestApi - factory interface
 * @export
 */
export const DailyDigestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DailyDigestApiFp(configuration)
    return {
        /**
         * Admin-only endpoint to manually trigger daily digest delivery for testing purposes
         * @summary Deliver latest daily digest for a user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliverDailyDigest(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deliverDailyDigest(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the most recent daily digest for the specified user from today
         * @summary Get latest daily digest for a user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestDailyDigest(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<DigestContentDto> {
            return localVarFp.getLatestDailyDigest(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Admin-only endpoint to manually trigger daily digest generation for testing purposes
         * @summary Trigger daily digest generation for a user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerDailyDigest(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.triggerDailyDigest(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DailyDigestApi - object-oriented interface
 * @export
 * @class DailyDigestApi
 * @extends {BaseAPI}
 */
export class DailyDigestApi extends BaseAPI {
    /**
     * Admin-only endpoint to manually trigger daily digest delivery for testing purposes
     * @summary Deliver latest daily digest for a user
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DailyDigestApi
     */
    public deliverDailyDigest(userId: string, options?: RawAxiosRequestConfig) {
        return DailyDigestApiFp(this.configuration).deliverDailyDigest(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the most recent daily digest for the specified user from today
     * @summary Get latest daily digest for a user
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DailyDigestApi
     */
    public getLatestDailyDigest(userId: string, options?: RawAxiosRequestConfig) {
        return DailyDigestApiFp(this.configuration).getLatestDailyDigest(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Admin-only endpoint to manually trigger daily digest generation for testing purposes
     * @summary Trigger daily digest generation for a user
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DailyDigestApi
     */
    public triggerDailyDigest(userId: string, options?: RawAxiosRequestConfig) {
        return DailyDigestApiFp(this.configuration).triggerDailyDigest(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FeedsApi - axios parameter creator
 * @export
 */
export const FeedsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new feed from RSS URL
         * @param {CreateFeedDto} createFeedDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeed: async (createFeedDto: CreateFeedDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createFeedDto' is not null or undefined
            assertParamExists('createFeed', 'createFeedDto', createFeedDto)
            const localVarPath = `/feeds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFeedDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a feed
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeed: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFeed', 'id', id)
            const localVarPath = `/feeds/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all feeds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllFeeds: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/feeds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a feed by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFeedById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findFeedById', 'id', id)
            const localVarPath = `/feeds/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trigger immediate feed scraping
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scrapeFeedNow: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('scrapeFeedNow', 'id', id)
            const localVarPath = `/feeds/{id}/scrape`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update feed properties
         * @param {string} id 
         * @param {UpdateFeedDto} updateFeedDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeed: async (id: string, updateFeedDto: UpdateFeedDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFeed', 'id', id)
            // verify required parameter 'updateFeedDto' is not null or undefined
            assertParamExists('updateFeed', 'updateFeedDto', updateFeedDto)
            const localVarPath = `/feeds/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFeedDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update feed status and scraping interval
         * @param {string} id 
         * @param {UpdateFeedStatusDto} updateFeedStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedStatus: async (id: string, updateFeedStatusDto: UpdateFeedStatusDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFeedStatus', 'id', id)
            // verify required parameter 'updateFeedStatusDto' is not null or undefined
            assertParamExists('updateFeedStatus', 'updateFeedStatusDto', updateFeedStatusDto)
            const localVarPath = `/feeds/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFeedStatusDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeedsApi - functional programming interface
 * @export
 */
export const FeedsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeedsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new feed from RSS URL
         * @param {CreateFeedDto} createFeedDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFeed(createFeedDto: CreateFeedDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFeed(createFeedDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeedsApi.createFeed']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a feed
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFeed(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFeed(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeedsApi.deleteFeed']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all feeds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllFeeds(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FeedDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllFeeds(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeedsApi.findAllFeeds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a feed by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findFeedById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findFeedById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeedsApi.findFeedById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Trigger immediate feed scraping
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scrapeFeedNow(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scrapeFeedNow(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeedsApi.scrapeFeedNow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update feed properties
         * @param {string} id 
         * @param {UpdateFeedDto} updateFeedDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFeed(id: string, updateFeedDto: UpdateFeedDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFeed(id, updateFeedDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeedsApi.updateFeed']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update feed status and scraping interval
         * @param {string} id 
         * @param {UpdateFeedStatusDto} updateFeedStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFeedStatus(id: string, updateFeedStatusDto: UpdateFeedStatusDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFeedStatus(id, updateFeedStatusDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeedsApi.updateFeedStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FeedsApi - factory interface
 * @export
 */
export const FeedsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeedsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new feed from RSS URL
         * @param {CreateFeedDto} createFeedDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeed(createFeedDto: CreateFeedDto, options?: RawAxiosRequestConfig): AxiosPromise<FeedDto> {
            return localVarFp.createFeed(createFeedDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a feed
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeed(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFeed(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all feeds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllFeeds(options?: RawAxiosRequestConfig): AxiosPromise<Array<FeedDto>> {
            return localVarFp.findAllFeeds(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a feed by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFeedById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FeedDto> {
            return localVarFp.findFeedById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Trigger immediate feed scraping
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scrapeFeedNow(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.scrapeFeedNow(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update feed properties
         * @param {string} id 
         * @param {UpdateFeedDto} updateFeedDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeed(id: string, updateFeedDto: UpdateFeedDto, options?: RawAxiosRequestConfig): AxiosPromise<FeedDto> {
            return localVarFp.updateFeed(id, updateFeedDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update feed status and scraping interval
         * @param {string} id 
         * @param {UpdateFeedStatusDto} updateFeedStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedStatus(id: string, updateFeedStatusDto: UpdateFeedStatusDto, options?: RawAxiosRequestConfig): AxiosPromise<FeedDto> {
            return localVarFp.updateFeedStatus(id, updateFeedStatusDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeedsApi - object-oriented interface
 * @export
 * @class FeedsApi
 * @extends {BaseAPI}
 */
export class FeedsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new feed from RSS URL
     * @param {CreateFeedDto} createFeedDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedsApi
     */
    public createFeed(createFeedDto: CreateFeedDto, options?: RawAxiosRequestConfig) {
        return FeedsApiFp(this.configuration).createFeed(createFeedDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a feed
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedsApi
     */
    public deleteFeed(id: string, options?: RawAxiosRequestConfig) {
        return FeedsApiFp(this.configuration).deleteFeed(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all feeds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedsApi
     */
    public findAllFeeds(options?: RawAxiosRequestConfig) {
        return FeedsApiFp(this.configuration).findAllFeeds(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a feed by ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedsApi
     */
    public findFeedById(id: string, options?: RawAxiosRequestConfig) {
        return FeedsApiFp(this.configuration).findFeedById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Trigger immediate feed scraping
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedsApi
     */
    public scrapeFeedNow(id: string, options?: RawAxiosRequestConfig) {
        return FeedsApiFp(this.configuration).scrapeFeedNow(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update feed properties
     * @param {string} id 
     * @param {UpdateFeedDto} updateFeedDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedsApi
     */
    public updateFeed(id: string, updateFeedDto: UpdateFeedDto, options?: RawAxiosRequestConfig) {
        return FeedsApiFp(this.configuration).updateFeed(id, updateFeedDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update feed status and scraping interval
     * @param {string} id 
     * @param {UpdateFeedStatusDto} updateFeedStatusDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedsApi
     */
    public updateFeedStatus(id: string, updateFeedStatusDto: UpdateFeedStatusDto, options?: RawAxiosRequestConfig) {
        return FeedsApiFp(this.configuration).updateFeedStatus(id, updateFeedStatusDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OnboardingApi - axios parameter creator
 * @export
 */
export const OnboardingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add article to onboarding
         * @param {string} id Onboarding ID
         * @param {AddArticleToOnboardingDto} addArticleToOnboardingDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addArticleToOnboarding: async (id: string, addArticleToOnboardingDto: AddArticleToOnboardingDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addArticleToOnboarding', 'id', id)
            // verify required parameter 'addArticleToOnboardingDto' is not null or undefined
            assertParamExists('addArticleToOnboarding', 'addArticleToOnboardingDto', addArticleToOnboardingDto)
            const localVarPath = `/onboarding/{id}/articles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addArticleToOnboardingDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new onboarding configuration
         * @param {CreateOnboardingDto} createOnboardingDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOnboarding: async (createOnboardingDto: CreateOnboardingDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOnboardingDto' is not null or undefined
            assertParamExists('createOnboarding', 'createOnboardingDto', createOnboardingDto)
            const localVarPath = `/onboarding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOnboardingDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete onboarding configuration
         * @param {string} id Onboarding ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOnboarding: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOnboarding', 'id', id)
            const localVarPath = `/onboarding/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get onboarding details
         * @param {string} id Onboarding ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOnboardingById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOnboardingById', 'id', id)
            const localVarPath = `/onboarding/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the current production onboarding configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductionOnboarding: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/onboarding/production`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all onboarding configurations
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOnboardings: async (limit?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/onboarding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Promote onboarding to production
         * @param {string} id Onboarding ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoteOnboardingToProduction: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('promoteOnboardingToProduction', 'id', id)
            const localVarPath = `/onboarding/{id}/promote`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove article from onboarding
         * @param {string} id Onboarding ID
         * @param {string} articleId Article ID to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeArticleFromOnboarding: async (id: string, articleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeArticleFromOnboarding', 'id', id)
            // verify required parameter 'articleId' is not null or undefined
            assertParamExists('removeArticleFromOnboarding', 'articleId', articleId)
            const localVarPath = `/onboarding/{id}/articles/{articleId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"articleId"}}`, encodeURIComponent(String(articleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update article positions in bulk
         * @param {string} id Onboarding ID
         * @param {UpdateArticlePositionsDto} updateArticlePositionsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOnboardingArticlePositions: async (id: string, updateArticlePositionsDto: UpdateArticlePositionsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateOnboardingArticlePositions', 'id', id)
            // verify required parameter 'updateArticlePositionsDto' is not null or undefined
            assertParamExists('updateOnboardingArticlePositions', 'updateArticlePositionsDto', updateArticlePositionsDto)
            const localVarPath = `/onboarding/{id}/articles/positions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateArticlePositionsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OnboardingApi - functional programming interface
 * @export
 */
export const OnboardingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OnboardingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add article to onboarding
         * @param {string} id Onboarding ID
         * @param {AddArticleToOnboardingDto} addArticleToOnboardingDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addArticleToOnboarding(id: string, addArticleToOnboardingDto: AddArticleToOnboardingDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OnboardingDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addArticleToOnboarding(id, addArticleToOnboardingDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OnboardingApi.addArticleToOnboarding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create new onboarding configuration
         * @param {CreateOnboardingDto} createOnboardingDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOnboarding(createOnboardingDto: CreateOnboardingDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OnboardingDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOnboarding(createOnboardingDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OnboardingApi.createOnboarding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete onboarding configuration
         * @param {string} id Onboarding ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOnboarding(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOnboarding(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OnboardingApi.deleteOnboarding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get onboarding details
         * @param {string} id Onboarding ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOnboardingById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OnboardingDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOnboardingById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OnboardingApi.getOnboardingById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the current production onboarding configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductionOnboarding(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OnboardingDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductionOnboarding(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OnboardingApi.getProductionOnboarding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all onboarding configurations
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOnboardings(limit?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOnboardingDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOnboardings(limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OnboardingApi.listOnboardings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Promote onboarding to production
         * @param {string} id Onboarding ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promoteOnboardingToProduction(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OnboardingDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promoteOnboardingToProduction(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OnboardingApi.promoteOnboardingToProduction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove article from onboarding
         * @param {string} id Onboarding ID
         * @param {string} articleId Article ID to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeArticleFromOnboarding(id: string, articleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OnboardingDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeArticleFromOnboarding(id, articleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OnboardingApi.removeArticleFromOnboarding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update article positions in bulk
         * @param {string} id Onboarding ID
         * @param {UpdateArticlePositionsDto} updateArticlePositionsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOnboardingArticlePositions(id: string, updateArticlePositionsDto: UpdateArticlePositionsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OnboardingDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOnboardingArticlePositions(id, updateArticlePositionsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OnboardingApi.updateOnboardingArticlePositions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OnboardingApi - factory interface
 * @export
 */
export const OnboardingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OnboardingApiFp(configuration)
    return {
        /**
         * 
         * @summary Add article to onboarding
         * @param {string} id Onboarding ID
         * @param {AddArticleToOnboardingDto} addArticleToOnboardingDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addArticleToOnboarding(id: string, addArticleToOnboardingDto: AddArticleToOnboardingDto, options?: RawAxiosRequestConfig): AxiosPromise<OnboardingDto> {
            return localVarFp.addArticleToOnboarding(id, addArticleToOnboardingDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new onboarding configuration
         * @param {CreateOnboardingDto} createOnboardingDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOnboarding(createOnboardingDto: CreateOnboardingDto, options?: RawAxiosRequestConfig): AxiosPromise<OnboardingDto> {
            return localVarFp.createOnboarding(createOnboardingDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete onboarding configuration
         * @param {string} id Onboarding ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOnboarding(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteOnboarding(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get onboarding details
         * @param {string} id Onboarding ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOnboardingById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<OnboardingDto> {
            return localVarFp.getOnboardingById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the current production onboarding configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductionOnboarding(options?: RawAxiosRequestConfig): AxiosPromise<OnboardingDto> {
            return localVarFp.getProductionOnboarding(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all onboarding configurations
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOnboardings(limit?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedOnboardingDto> {
            return localVarFp.listOnboardings(limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Promote onboarding to production
         * @param {string} id Onboarding ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoteOnboardingToProduction(id: string, options?: RawAxiosRequestConfig): AxiosPromise<OnboardingDto> {
            return localVarFp.promoteOnboardingToProduction(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove article from onboarding
         * @param {string} id Onboarding ID
         * @param {string} articleId Article ID to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeArticleFromOnboarding(id: string, articleId: string, options?: RawAxiosRequestConfig): AxiosPromise<OnboardingDto> {
            return localVarFp.removeArticleFromOnboarding(id, articleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update article positions in bulk
         * @param {string} id Onboarding ID
         * @param {UpdateArticlePositionsDto} updateArticlePositionsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOnboardingArticlePositions(id: string, updateArticlePositionsDto: UpdateArticlePositionsDto, options?: RawAxiosRequestConfig): AxiosPromise<OnboardingDto> {
            return localVarFp.updateOnboardingArticlePositions(id, updateArticlePositionsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OnboardingApi - object-oriented interface
 * @export
 * @class OnboardingApi
 * @extends {BaseAPI}
 */
export class OnboardingApi extends BaseAPI {
    /**
     * 
     * @summary Add article to onboarding
     * @param {string} id Onboarding ID
     * @param {AddArticleToOnboardingDto} addArticleToOnboardingDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnboardingApi
     */
    public addArticleToOnboarding(id: string, addArticleToOnboardingDto: AddArticleToOnboardingDto, options?: RawAxiosRequestConfig) {
        return OnboardingApiFp(this.configuration).addArticleToOnboarding(id, addArticleToOnboardingDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new onboarding configuration
     * @param {CreateOnboardingDto} createOnboardingDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnboardingApi
     */
    public createOnboarding(createOnboardingDto: CreateOnboardingDto, options?: RawAxiosRequestConfig) {
        return OnboardingApiFp(this.configuration).createOnboarding(createOnboardingDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete onboarding configuration
     * @param {string} id Onboarding ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnboardingApi
     */
    public deleteOnboarding(id: string, options?: RawAxiosRequestConfig) {
        return OnboardingApiFp(this.configuration).deleteOnboarding(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get onboarding details
     * @param {string} id Onboarding ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnboardingApi
     */
    public getOnboardingById(id: string, options?: RawAxiosRequestConfig) {
        return OnboardingApiFp(this.configuration).getOnboardingById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the current production onboarding configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnboardingApi
     */
    public getProductionOnboarding(options?: RawAxiosRequestConfig) {
        return OnboardingApiFp(this.configuration).getProductionOnboarding(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all onboarding configurations
     * @param {number} [limit] 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnboardingApi
     */
    public listOnboardings(limit?: number, page?: number, options?: RawAxiosRequestConfig) {
        return OnboardingApiFp(this.configuration).listOnboardings(limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Promote onboarding to production
     * @param {string} id Onboarding ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnboardingApi
     */
    public promoteOnboardingToProduction(id: string, options?: RawAxiosRequestConfig) {
        return OnboardingApiFp(this.configuration).promoteOnboardingToProduction(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove article from onboarding
     * @param {string} id Onboarding ID
     * @param {string} articleId Article ID to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnboardingApi
     */
    public removeArticleFromOnboarding(id: string, articleId: string, options?: RawAxiosRequestConfig) {
        return OnboardingApiFp(this.configuration).removeArticleFromOnboarding(id, articleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update article positions in bulk
     * @param {string} id Onboarding ID
     * @param {UpdateArticlePositionsDto} updateArticlePositionsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnboardingApi
     */
    public updateOnboardingArticlePositions(id: string, updateArticlePositionsDto: UpdateArticlePositionsDto, options?: RawAxiosRequestConfig) {
        return OnboardingApiFp(this.configuration).updateOnboardingArticlePositions(id, updateArticlePositionsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Approves a user and sends them an approval email notification
         * @summary Approve a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveUser: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('approveUser', 'id', id)
            const localVarPath = `/users/{id}/approve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createUser', 'body', body)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findUserById', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} hour 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsersByDigestHour: async (hour: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hour' is not null or undefined
            assertParamExists('findUsersByDigestHour', 'hour', hour)
            const localVarPath = `/users/digest/{hour}`
                .replace(`{${"hour"}}`, encodeURIComponent(String(hour)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUser: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDigestTime: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserDigestTime', 'id', id)
            const localVarPath = `/users/{id}/digest-time`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPreferences: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserPreferences', 'id', id)
            const localVarPath = `/users/{id}/preferences`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Approves a user and sends them an approval email notification
         * @summary Approve a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveUser(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveUser(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.approveUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.createUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUserById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUserById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.findUserById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} hour 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUsersByDigestHour(hour: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUsersByDigestHour(hour, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.findUsersByDigestHour']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUser(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUser(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.removeUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserDigestTime(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserDigestTime(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserDigestTime']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPreferences(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPreferences(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserPreferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Approves a user and sends them an approval email notification
         * @summary Approve a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveUser(id: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.approveUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: object, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createUser(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.findUserById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} hour 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsersByDigestHour(hour: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.findUsersByDigestHour(hour, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUser(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDigestTime(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateUserDigestTime(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPreferences(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateUserPreferences(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Approves a user and sends them an approval email notification
     * @summary Approve a user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public approveUser(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).approveUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(body: object, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUser(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findUserById(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).findUserById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} hour 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findUsersByDigestHour(hour: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).findUsersByDigestHour(hour, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public removeUser(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).removeUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserDigestTime(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserDigestTime(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserPreferences(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserPreferences(id, options).then((request) => request(this.axios, this.basePath));
    }
}



